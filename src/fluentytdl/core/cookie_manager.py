"""
FluentYTDL Cookie 管理模块

解决 Chrome Cookie 文件锁问题，支持:
- 浏览器运行时提取 Cookie (使用 rookiepy)
- 多账户管理
- Netscape 格式导出 (yt-dlp 兼容)
- Cookie 有效性验证
"""

from __future__ import annotations

import json
import tempfile
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Any

from ..utils.logger import logger

# 尝试导入 rookiepy
try:
    import rookiepy
    HAS_ROOKIEPY = True
except ImportError:
    HAS_ROOKIEPY = False
    logger.warning("rookiepy 未安装，Cookie 自动提取功能不可用")


# 支持的浏览器列表
SUPPORTED_BROWSERS = ["chrome", "edge", "firefox", "brave", "chromium", "opera"]

# 各平台需要的 Cookie 域名
PLATFORM_DOMAINS = {
    "youtube": [".youtube.com", ".google.com"],
    "bilibili": [".bilibili.com"],
    "twitter": [".twitter.com", ".x.com"],
    "tiktok": [".tiktok.com"],
}

# YouTube 登录所需的关键 Cookie
YOUTUBE_REQUIRED_COOKIES = {"SID", "HSID", "SSID", "SAPISID", "APISID"}


@dataclass
class AuthProfile:
    """
    认证配置文件
    
    管理单个平台/账户的 Cookie 配置。
    """
    name: str                          # 显示名称 (如 "YouTube 会员")
    platform: str                      # 平台标识 (youtube, bilibili)
    cookie_source: str                 # 来源 (chrome, edge, file)
    cookie_path: str | None = None     # cookies.txt 路径 (当 source=file)
    user_agent: str | None = None      # 自定义 User-Agent
    enabled: bool = True               # 是否启用
    last_updated: str | None = None    # 最后更新时间
    cookie_count: int = 0              # Cookie 数量
    is_valid: bool = False             # 是否验证有效
    
    def to_dict(self) -> dict[str, Any]:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> AuthProfile:
        known = {f.name for f in cls.__dataclass_fields__.values()}
        return cls(**{k: v for k, v in data.items() if k in known})


class CookieManager:
    """
    Cookie 管理器
    
    支持从浏览器提取 Cookie 并生成 yt-dlp 兼容的 cookies.txt。
    使用 rookiepy 绕过 Chrome 文件锁问题。
    """
    
    def __init__(self, cache_dir: Path | None = None):
        """
        初始化 Cookie 管理器
        
        Args:
            cache_dir: Cookie 缓存目录
        """
        self.cache_dir = cache_dir or Path(tempfile.gettempdir()) / "fluentytdl_cookies"
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        self._profiles: dict[str, AuthProfile] = {}
        self._profiles_path = self.cache_dir / "profiles.json"
        
        self._load_profiles()
    
    @property
    def available(self) -> bool:
        """是否可用 (rookiepy 已安装)"""
        return HAS_ROOKIEPY
    
    def extract_cookies(
        self,
        browser: str = "chrome",
        domains: list[str] | None = None,
    ) -> list[dict[str, Any]]:
        """
        从浏览器提取 Cookie
        
        使用 rookiepy 的 Shadow Copy 策略绕过文件锁。
        
        Args:
            browser: 浏览器名称 (chrome, edge, firefox, brave)
            domains: 要提取的域名列表
            
        Returns:
            Cookie 列表
            
        Raises:
            RuntimeError: 提取失败
        """
        if not HAS_ROOKIEPY:
            raise RuntimeError("rookiepy 未安装，请运行 pip install rookiepy")
        
        browser = browser.lower()
        if browser not in SUPPORTED_BROWSERS:
            raise ValueError(f"不支持的浏览器: {browser}")
        
        domains = domains or [".youtube.com", ".google.com"]
        
        try:
            # rookiepy 会自动处理文件锁
            extractor = getattr(rookiepy, browser, None)
            if extractor is None:
                raise RuntimeError(f"rookiepy 不支持 {browser}")
            
            cookies = extractor(domains)
            logger.info(f"从 {browser} 提取到 {len(cookies)} 个 Cookie")
            return cookies
            
        except Exception as e:
            raise RuntimeError(f"Cookie 提取失败: {e}")
    
    def to_netscape_file(
        self,
        cookies: list[dict[str, Any]],
        output_path: Path | None = None,
    ) -> Path:
        """
        将 Cookie 转换为 Netscape 格式文件
        
        这是 yt-dlp --cookies 参数支持的标准格式。
        
        Args:
            cookies: Cookie 列表
            output_path: 输出路径，None 则自动生成
            
        Returns:
            cookies.txt 文件路径
        """
        if output_path is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_path = self.cache_dir / f"cookies_{timestamp}.txt"
        
        lines = [
            "# Netscape HTTP Cookie File",
            "# Generated by FluentYTDL",
            f"# {datetime.now().isoformat()}",
            "",
        ]
        
        for c in cookies:
            # Netscape 格式: domain, flag, path, secure, expiry, name, value
            domain = c.get("domain", "")
            flag = "TRUE" if domain.startswith(".") else "FALSE"
            path = c.get("path", "/")
            secure = "TRUE" if c.get("secure", False) else "FALSE"
            expiry = str(int(c.get("expires", 0) or 0))
            name = c.get("name", "")
            value = c.get("value", "")
            
            lines.append(f"{domain}\t{flag}\t{path}\t{secure}\t{expiry}\t{name}\t{value}")
        
        output_path.write_text("\n".join(lines), encoding="utf-8")
        logger.debug(f"已生成 cookies.txt: {output_path}")
        return output_path
    
    def get_cookies_for_ytdlp(
        self,
        browser: str = "chrome",
        platform: str = "youtube",
    ) -> str:
        """
        一键获取 yt-dlp 可用的 cookies.txt 路径
        
        Args:
            browser: 浏览器名称
            platform: 平台标识
            
        Returns:
            cookies.txt 文件的绝对路径
        """
        domains = PLATFORM_DOMAINS.get(platform, [".youtube.com", ".google.com"])
        cookies = self.extract_cookies(browser, domains)
        
        if not cookies:
            raise RuntimeError(f"未找到 {platform} 的 Cookie，请确保已在 {browser} 中登录")
        
        cookie_file = self.to_netscape_file(cookies)
        return str(cookie_file)
    
    def validate_cookies(
        self,
        cookies: list[dict[str, Any]],
        platform: str = "youtube",
    ) -> dict[str, Any]:
        """
        验证 Cookie 有效性
        
        Args:
            cookies: Cookie 列表
            platform: 平台标识
            
        Returns:
            验证结果 {"valid": bool, "message": str, "found": set}
        """
        found = {c.get("name", "") for c in cookies}
        
        if platform == "youtube":
            required = YOUTUBE_REQUIRED_COOKIES
            missing = required - found
            
            if missing:
                return {
                    "valid": False,
                    "message": f"缺少必需 Cookie: {missing}",
                    "found": found,
                    "missing": missing,
                }
            return {
                "valid": True,
                "message": "Cookie 有效 (检测到登录状态)",
                "found": found,
                "missing": set(),
            }
        else:
            # 其他平台只检查是否有 Cookie
            if cookies:
                return {
                    "valid": True,
                    "message": f"找到 {len(cookies)} 个 Cookie",
                    "found": found,
                }
            return {
                "valid": False,
                "message": "未找到 Cookie",
                "found": found,
            }
    
    # ==================== 配置文件管理 ====================
    
    def add_profile(self, profile: AuthProfile) -> None:
        """添加认证配置"""
        key = f"{profile.platform}_{profile.name}"
        self._profiles[key] = profile
        self._save_profiles()
    
    def remove_profile(self, platform: str, name: str) -> bool:
        """移除认证配置"""
        key = f"{platform}_{name}"
        if key in self._profiles:
            del self._profiles[key]
            self._save_profiles()
            return True
        return False
    
    def get_profiles(self, platform: str | None = None) -> list[AuthProfile]:
        """获取认证配置列表"""
        profiles = list(self._profiles.values())
        if platform:
            profiles = [p for p in profiles if p.platform == platform]
        return profiles
    
    def get_active_profile(self, platform: str) -> AuthProfile | None:
        """获取指定平台的活跃配置"""
        for p in self._profiles.values():
            if p.platform == platform and p.enabled:
                return p
        return None
    
    def refresh_profile(self, profile: AuthProfile) -> bool:
        """刷新配置中的 Cookie"""
        try:
            if profile.cookie_source in SUPPORTED_BROWSERS:
                domains = PLATFORM_DOMAINS.get(profile.platform, [".youtube.com"])
                cookies = self.extract_cookies(profile.cookie_source, domains)
                
                # 生成并保存 Cookie 文件
                cookie_path = self.cache_dir / f"{profile.platform}_{profile.name}.txt"
                self.to_netscape_file(cookies, cookie_path)
                
                # 验证
                validation = self.validate_cookies(cookies, profile.platform)
                
                # 更新配置
                profile.cookie_path = str(cookie_path)
                profile.last_updated = datetime.now().isoformat()
                profile.cookie_count = len(cookies)
                profile.is_valid = validation["valid"]
                
                self._save_profiles()
                return True
            
        except Exception as e:
            logger.error(f"刷新 Cookie 失败: {e}")
            profile.is_valid = False
            self._save_profiles()
        
        return False
    
    def _save_profiles(self) -> None:
        """保存配置到文件"""
        data = {
            "version": 1,
            "profiles": [p.to_dict() for p in self._profiles.values()],
            "updated_at": datetime.now().isoformat(),
        }
        with open(self._profiles_path, "w", encoding="utf-8") as f:
            f.write(json.dumps(data, ensure_ascii=False, indent=2))
    
    def _load_profiles(self) -> None:
        """从文件加载配置"""
        if not self._profiles_path.exists():
            return
        
        try:
            with open(self._profiles_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            for p_data in data.get("profiles", []):
                profile = AuthProfile.from_dict(p_data)
                key = f"{profile.platform}_{profile.name}"
                self._profiles[key] = profile
            logger.info(f"已加载 {len(self._profiles)} 个认证配置")
        except Exception as e:
            logger.error(f"加载认证配置失败: {e}")
    
    def cleanup_old_cookies(self, max_age_hours: int = 24) -> int:
        """清理过期的 Cookie 文件"""
        cleaned = 0
        now = datetime.now()
        
        for f in self.cache_dir.glob("cookies_*.txt"):
            try:
                mtime = datetime.fromtimestamp(f.stat().st_mtime)
                age_hours = (now - mtime).total_seconds() / 3600
                if age_hours > max_age_hours:
                    f.unlink()
                    cleaned += 1
            except Exception:
                pass
        
        return cleaned


# 全局实例
cookie_manager = CookieManager()
